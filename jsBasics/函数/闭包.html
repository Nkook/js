<!DOCTYPE html>
<html lang="en">
<head>
 <meta charset="UTF-8">
 <meta http-equiv="X-UA-Compatible" content="IE=edge">
 <meta name="viewport" content="width=device-width, initial-scale=1.0">
 <title>Document</title>
</head>
<body>
 <script>
  // 作用域链
  // 每个函数都会创建一个新的作用域
  // 函数外部无法访问函数内部的值：因为内部执行完成之后就被销毁了，内存里不再存在，当再次调用的时候有，调用完又会被销毁。
  // 函数内部的值可以访问函数外部的值
  // let str = "hello"
  // function fun1() {
  //  let str = "world"
  //  let num = 10
  //  // fun2是个闭包函数
  //  function fun2() {
  //   console.log('fun2', str) // world
  //   console.log('fun2', num) // 10
  //  }
  //  fun2()
  // }
  // fun1()
  // console.log(num) // 为啥无法输出，因为fun1执行完之后，里面的num就被销毁了。

  // 闭包
  // 闭包函数：声明在一个函数中的函数，叫做闭包函数
  // 闭包：内部函数总是能访问其所在外部函数中声明的参数和变量，即使在其外部函数被返回了之后。（内部函数被返回未执行完，外部函数不会被销毁）
  // 想在全局环境下外部访问内部闭包函数，将闭包return出来即可。让fun1的返回值是fun2函数
  // function fun1() {
  //   function fun2() {
  //    console.log('我是fun2')
  //   }
  //   return fun2
  // }
  // const f = fun1()
  // f()

  // fun2是fun1内部的一个变量
  // 通过返回值方式得到fun2,但无法在外部得到n和m。利用闭包实现了代码的封装。希望暴漏的方法通过返回值暴漏
  // 闭包的特性：如果内部函数作为一个返回值赋值给外部一个变量的话，当外部函数fun1执行完成之后，里面的变量是不会被销毁的
  //           内部函数未执行完，外部函数即使执行完成，外部函数中的变量也不会被销毁。
  function fun1() {
    let n = 10
    let m = 20
    function fun2() {
     return n+m
    }
    return fun2
  }
  const f = fun1() //这里执行完fun1后，里面的变量和函数都被销毁了，还怎么执行fun2？这就是闭包的特性
  const result = f()
  console.log(result) // 30



 </script>
</body>
</html>